{"games":[{"gameUrl":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n    <title>Star Guardian</title>\n    <style>\n        body { margin: 0; overflow: hidden; touch-action: none; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }\n        canvas { display: block; width: 100vw; height: 100vh; }\n        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: white; }\n        .screen { \n            position: absolute; top: 0; left: 0; width: 100%; height: 100%; \n            display: flex; flex-direction: column; justify-content: center; align-items: center; \n            background: rgba(0,0,0,0.7); pointer-events: auto;\n        }\n        h1 { font-size: 3rem; margin: 0; color: #0ff; text-shadow: 0 0 10px #0ff; }\n        p { font-size: 1.2rem; }\n        button { \n            padding: 15px 40px; font-size: 1.5rem; background: transparent; \n            border: 2px solid #0ff; color: #0ff; cursor: pointer; border-radius: 50px;\n            transition: 0.3s;\n        }\n        button:hover { background: #0ff; color: #000; }\n        #hud { position: absolute; top: 20px; left: 20px; font-size: 24px; font-weight: bold; color: #0ff; }\n    </style>\n</head>\n<body>\n\n    <canvas id=\"gameCanvas\"></canvas>\n    \n    <div id=\"ui\">\n        <div id=\"hud\">SCORE: 0</div>\n        \n        <div id=\"startScreen\" class=\"screen\">\n            <h1>STAR GUARDIAN</h1>\n            <p>Drag or move mouse to fly and shoot</p>\n            <button onclick=\"startGame()\">START MISSION</button>\n        </div>\n\n        <div id=\"gameOverScreen\" class=\"screen\" style=\"display:none;\">\n            <h1>MISSION FAILED</h1>\n            <p id=\"finalScore\">SCORE: 0</p>\n            <button onclick=\"startGame()\">REDEPLOY</button>\n        </div>\n    </div>\n\n    <script>\n        const canvas = document.getElementById('gameCanvas');\n        const ctx = canvas.getContext('2d');\n        const hud = document.getElementById('hud');\n        const startScreen = document.getElementById('startScreen');\n        const gameOverScreen = document.getElementById('gameOverScreen');\n        const finalScoreText = document.getElementById('finalScore');\n\n        let width, height, player, projectiles, enemies, particles, stars, score, gameActive, lastTime;\n\n        function resize() {\n            width = canvas.width = window.innerWidth;\n            height = canvas.height = window.innerHeight;\n        }\n        window.addEventListener('resize', resize);\n        resize();\n\n        class Player {\n            constructor() {\n                this.x = width / 2;\n                this.y = height * 0.8;\n                this.radius = 20;\n                this.targetX = this.x;\n                this.targetY = this.y;\n                this.fireRate = 150;\n                this.lastFire = 0;\n            }\n            update(dt) {\n                this.x += (this.targetX - this.x) * 0.15;\n                this.y += (this.targetY - this.y) * 0.15;\n                \n                if (Date.now() - this.lastFire > this.fireRate) {\n                    projectiles.push(new Projectile(this.x, this.y - 20));\n                    this.lastFire = Date.now();\n                }\n            }\n            draw() {\n                ctx.save();\n                ctx.translate(this.x, this.y);\n                // Ship Body\n                ctx.fillStyle = '#0ff';\n                ctx.beginPath();\n                ctx.moveTo(0, -25);\n                ctx.lineTo(20, 15);\n                ctx.lineTo(0, 5);\n                ctx.lineTo(-20, 15);\n                ctx.closePath();\n                ctx.fill();\n                // Glow\n                ctx.shadowBlur = 15;\n                ctx.shadowColor = '#0ff';\n                ctx.stroke();\n                ctx.restore();\n            }\n        }\n\n        class Projectile {\n            constructor(x, y) {\n                this.x = x;\n                this.y = y;\n                this.speed = 12;\n                this.radius = 3;\n            }\n            update() {\n                this.y -= this.speed;\n            }\n            draw() {\n                ctx.fillStyle = '#fff';\n                ctx.shadowBlur = 10;\n                ctx.shadowColor = '#0ff';\n                ctx.fillRect(this.x - 2, this.y, 4, 15);\n            }\n        }\n\n        class Enemy {\n            constructor() {\n                this.x = Math.random() * (width - 40) + 20;\n                this.y = -50;\n                this.speed = 2 + Math.random() * 3;\n                this.radius = 18;\n                this.hp = 1;\n                this.color = `hsl(${Math.random() * 60 + 300}, 100%, 60%)`;\n            }\n            update() {\n                this.y += this.speed;\n                this.x += Math.sin(this.y / 50) * 2;\n            }\n            draw() {\n                ctx.save();\n                ctx.translate(this.x, this.y);\n                ctx.fillStyle = this.color;\n                ctx.shadowBlur = 15;\n                ctx.shadowColor = this.color;\n                ctx.beginPath();\n                ctx.moveTo(0, 20);\n                ctx.lineTo(15, -10);\n                ctx.lineTo(-15, -10);\n                ctx.closePath();\n                ctx.fill();\n                ctx.restore();\n            }\n        }\n\n        class Particle {\n            constructor(x, y, color) {\n                this.x = x;\n                this.y = y;\n                this.color = color;\n                this.vx = (Math.random() - 0.5) * 10;\n                this.vy = (Math.random() - 0.5) * 10;\n                this.alpha = 1;\n                this.life = 1.0;\n            }\n            update() {\n                this.x += this.vx;\n                this.y += this.vy;\n                this.life -= 0.02;\n            }\n            draw() {\n                ctx.globalAlpha = this.life;\n                ctx.fillStyle = this.color;\n                ctx.fillRect(this.x, this.y, 3, 3);\n                ctx.globalAlpha = 1;\n            }\n        }\n\n        function initStars() {\n            stars = [];\n            for (let i = 0; i < 100; i++) {\n                stars.push({\n                    x: Math.random() * width,\n                    y: Math.random() * height,\n                    size: Math.random() * 2,\n                    speed: Math.random() * 3 + 1\n                });\n            }\n        }\n\n        function spawnEnemy() {\n            if (gameActive && Math.random() < 0.05) {\n                enemies.push(new Enemy());\n            }\n        }\n\n        function checkCollisions() {\n            for (let i = projectiles.length - 1; i >= 0; i--) {\n                for (let j = enemies.length - 1; j >= 0; j--) {\n                    const dx = projectiles[i].x - enemies[j].x;\n                    const dy = projectiles[i].y - enemies[j].y;\n                    const dist = Math.sqrt(dx * dx + dy * dy);\n\n                    if (dist < projectiles[i].radius + enemies[j].radius) {\n                        // Hit\n                        for (let k = 0; k < 10; k++) particles.push(new Particle(enemies[j].x, enemies[j].y, enemies[j].color));\n                        enemies.splice(j, 1);\n                        projectiles.splice(i, 1);\n                        score += 100;\n                        hud.innerText = `SCORE: ${score}`;\n                        break;\n                    }\n                }\n            }\n\n            for (let i = enemies.length - 1; i >= 0; i--) {\n                const dx = player.x - enemies[i].x;\n                const dy = player.y - enemies[i].y;\n                const dist = Math.sqrt(dx * dx + dy * dy);\n\n                if (dist < player.radius + enemies[i].radius) {\n                    endGame();\n                }\n            }\n        }\n\n        function startGame() {\n            player = new Player();\n            projectiles = [];\n            enemies = [];\n            particles = [];\n            score = 0;\n            gameActive = true;\n            hud.innerText = `SCORE: 0`;\n            startScreen.style.display = 'none';\n            gameOverScreen.style.display = 'none';\n            initStars();\n            requestAnimationFrame(gameLoop);\n        }\n\n        function endGame() {\n            gameActive = false;\n            gameOverScreen.style.display = 'flex';\n            finalScoreText.innerText = `FINAL SCORE: ${score}`;\n        }\n\n        function gameLoop(time) {\n            if (!gameActive) return;\n            ctx.fillStyle = '#000814';\n            ctx.fillRect(0, 0, width, height);\n\n            // Background stars\n            ctx.fillStyle = '#fff';\n            stars.forEach(star => {\n                star.y += star.speed;\n                if (star.y > height) star.y = 0;\n                ctx.fillRect(star.x, star.y, star.size, star.size);\n            });\n\n            player.update();\n            player.draw();\n\n            spawnEnemy();\n\n            projectiles.forEach((p, i) => {\n                p.update();\n                p.draw();\n                if (p.y < -20) projectiles.splice(i, 1);\n            });\n\n            enemies.forEach((e, i) => {\n                e.update();\n                e.draw();\n                if (e.y > height + 20) enemies.splice(i, 1);\n            });\n\n            particles.forEach((p, i) => {\n                p.update();\n                p.draw();\n                if (p.life <= 0) particles.splice(i, 1);\n            });\n\n            checkCollisions();\n            requestAnimationFrame(gameLoop);\n        }\n\n        function handleInput(e) {\n            const x = e.touches ? e.touches[0].clientX : e.clientX;\n            const y = e.touches ? e.touches[0].clientY : e.clientY;\n            if (player) {\n                player.targetX = x;\n                player.targetY = y - 40;\n            }\n        }\n\n        window.addEventListener('mousemove', handleInput);\n        window.addEventListener('touchmove', (e) => {\n            e.preventDefault();\n            handleInput(e);\n        }, { passive: false });\n\n    </script>\n</body>\n</html>","title":"My Game","thumbnailUrl":"https://picsum.photos/seed/1767892573049/400/600","gameType":"html5","createdAt":"2026-01-08T18:16:13.052580","playCount":0,"description":"test game","shareCount":0,"commentCount":0,"creator":{"displayName":"aymanon","id":"rfsHDzhIygWDjkEoDT7RDvwBI2u1","username":"aymanon","profilePicture":"https://api.dicebear.com/7.x/avataaars/png?seed=rfsHDzhIygWDjkEoDT7RDvwBI2u1"},"likeCount":0,"hashtags":["#GameAI","#MadeWithPlai"],"id":"0KCOlPNqT9Izygku4XBV"},{"playCount":19,"id":"1"},{"playCount":4,"id":"2"},{"playCount":2,"id":"3"},{"playCount":2,"id":"4"},{"playCount":3,"id":"5"},{"playCount":4,"id":"6"},{"playCount":4,"id":"7"},{"playCount":8,"id":"8"},{"commentCount":0,"gameUrl":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n    <title>Gem Match Relax</title>\n    <style>\n        body { margin: 0; overflow: hidden; touch-action: none; background: #1a1a2e; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }\n        canvas { display: block; width: 100vw; height: 100vh; }\n        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }\n        .overlay { background: rgba(0,0,0,0.7); padding: 2rem; border-radius: 20px; text-align: center; pointer-events: auto; border: 2px solid #4e4e91; }\n        h1 { margin: 0 0 1rem 0; font-size: 3rem; color: #00d2ff; }\n        button { background: #4e4e91; border: none; color: white; padding: 15px 30px; font-size: 1.5rem; border-radius: 10px; cursor: pointer; transition: transform 0.1s; }\n        button:active { transform: scale(0.95); }\n    </style>\n</head>\n<body>\n    <canvas id=\"gameCanvas\"></canvas>\n    <div id=\"ui\">\n        <div id=\"startScreen\" class=\"overlay\">\n            <h1>Gem Match</h1>\n            <p>Swap gems to match 3 or more!</p>\n            <button onclick=\"startGame()\">Tap to Play</button>\n        </div>\n        <div id=\"gameOverScreen\" class=\"overlay\" style=\"display:none\">\n            <h1>Time's Up!</h1>\n            <p id=\"finalScore\">Score: 0</p>\n            <button onclick=\"startGame()\">Play Again</button>\n        </div>\n    </div>\n\n<script>\n    const canvas = document.getElementById('gameCanvas');\n    const ctx = canvas.getContext('2d');\n    const startScreen = document.getElementById('startScreen');\n    const gameOverScreen = document.getElementById('gameOverScreen');\n    const finalScoreText = document.getElementById('finalScore');\n\n    const GRID_SIZE = 7;\n    const COLORS = ['#FF595E', '#FFCA3A', '#8AC926', '#1982C4', '#6A4C93', '#FF924C'];\n    let cellSize, offsetX, offsetY;\n    let grid = [];\n    let score = 0;\n    let timeLeft = 60;\n    let gameState = 'START';\n    let selectedGem = null;\n    let animations = [];\n    let lastTime = 0;\n\n    function initGrid() {\n        grid = [];\n        for (let r = 0; r < GRID_SIZE; r++) {\n            grid[r] = [];\n            for (let c = 0; c < GRID_SIZE; c++) {\n                grid[r][c] = {\n                    type: Math.floor(Math.random() * COLORS.length),\n                    x: c, y: r,\n                    targetX: c, targetY: r,\n                    offsetY: -GRID_SIZE, // Start from above for drop animation\n                    scale: 1,\n                    alpha: 1\n                };\n            }\n        }\n        // Ensure no starting matches\n        resolveMatches(true);\n        score = 0;\n        timeLeft = 60;\n    }\n\n    function resize() {\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        cellSize = Math.min(canvas.width / (GRID_SIZE + 1), canvas.height / (GRID_SIZE + 2));\n        offsetX = (canvas.width - cellSize * GRID_SIZE) / 2;\n        offsetY = (canvas.height - cellSize * GRID_SIZE) / 2 + 20;\n    }\n\n    window.addEventListener('resize', resize);\n    resize();\n\n    function startGame() {\n        initGrid();\n        gameState = 'PLAYING';\n        startScreen.style.display = 'none';\n        gameOverScreen.style.display = 'none';\n        lastTime = performance.now();\n        requestAnimationFrame(gameLoop);\n    }\n\n    function getMousePos(e) {\n        const rect = canvas.getBoundingClientRect();\n        const clientX = e.touches ? e.touches[0].clientX : e.clientX;\n        const clientY = e.touches ? e.touches[0].clientY : e.clientY;\n        return {\n            x: (clientX - offsetX) / cellSize,\n            y: (clientY - offsetY) / cellSize\n        };\n    }\n\n    function handleInput(e) {\n        if (gameState !== 'PLAYING' || animations.length > 0) return;\n        const pos = getMousePos(e);\n        const c = Math.floor(pos.x);\n        const r = Math.floor(pos.y);\n\n        if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE) {\n            if (!selectedGem) {\n                selectedGem = { r, c };\n            } else {\n                const dist = Math.abs(r - selectedGem.r) + Math.abs(c - selectedGem.c);\n                if (dist === 1) {\n                    swapGems(selectedGem.r, selectedGem.c, r, c);\n                    selectedGem = null;\n                } else {\n                    selectedGem = { r, c };\n                }\n            }\n        }\n    }\n\n    canvas.addEventListener('mousedown', handleInput);\n    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(e); });\n\n    function swapGems(r1, c1, r2, c2) {\n        const gem1 = grid[r1][c1];\n        const gem2 = grid[r2][c2];\n        \n        // Swap in data\n        grid[r1][c1] = gem2;\n        grid[r2][c2] = gem1;\n        \n        if (!checkMatches()) {\n            // Swap back if no match\n            setTimeout(() => {\n                grid[r1][c1] = gem1;\n                grid[r2][c2] = gem2;\n            }, 300);\n        } else {\n            resolveMatches();\n        }\n    }\n\n    function checkMatches() {\n        let matched = false;\n        const toRemove = new Set();\n\n        // Horizontal\n        for (let r = 0; r < GRID_SIZE; r++) {\n            for (let c = 0; c < GRID_SIZE - 2; c++) {\n                if (grid[r][c].type === grid[r][c+1].type && grid[r][c].type === grid[r][c+2].type) {\n                    toRemove.add(`${r},${c}`); toRemove.add(`${r},${c+1}`); toRemove.add(`${r},${c+2}`);\n                    matched = true;\n                }\n            }\n        }\n        // Vertical\n        for (let c = 0; c < GRID_SIZE; c++) {\n            for (let r = 0; r < GRID_SIZE - 2; r++) {\n                if (grid[r][c].type === grid[r+1][c].type && grid[r+2][c].type === grid[r][c].type) {\n                    toRemove.add(`${r},${c}`); toRemove.add(`${r+1},${c}`); toRemove.add(`${r+2},${c}`);\n                    matched = true;\n                }\n            }\n        }\n        return matched ? toRemove : null;\n    }\n\n    function resolveMatches(silent = false) {\n        const matches = checkMatches();\n        if (matches) {\n            if (!silent) score += matches.size * 10;\n            \n            matches.forEach(pos => {\n                const [r, c] = pos.split(',').map(Number);\n                grid[r][c].alpha = 0; // Trigger \"pop\"\n            });\n\n            setTimeout(() => {\n                // Drop gems\n                for (let c = 0; c < GRID_SIZE; c++) {\n                    let emptySlots = 0;\n                    for (let r = GRID_SIZE - 1; r >= 0; r--) {\n                        if (grid[r][c].alpha === 0) {\n                            emptySlots++;\n                        } else if (emptySlots > 0) {\n                            grid[r + emptySlots][c] = grid[r][c];\n                            grid[r][c] = null;\n                        }\n                    }\n                    for (let r = 0; r < emptySlots; r++) {\n                        grid[r][c] = {\n                            type: Math.floor(Math.random() * COLORS.length),\n                            offsetY: -emptySlots,\n                            alpha: 1\n                        };\n                    }\n                }\n                resolveMatches(silent);\n            }, silent ? 0 : 200);\n        }\n    }\n\n    function drawGem(ctx, x, y, type, scale = 1, alpha = 1, isSelected = false) {\n        const size = cellSize * 0.8 * scale;\n        ctx.save();\n        ctx.translate(x + cellSize / 2, y + cellSize / 2);\n        ctx.globalAlpha = alpha;\n        \n        if (isSelected) {\n            ctx.strokeStyle = 'white';\n            ctx.lineWidth = 4;\n            ctx.strokeRect(-cellSize/2 + 5, -cellSize/2 + 5, cellSize - 10, cellSize - 10);\n        }\n\n        ctx.fillStyle = COLORS[type];\n        ctx.beginPath();\n        // Draw diamond shape\n        ctx.moveTo(0, -size/2);\n        ctx.lineTo(size/2, 0);\n        ctx.lineTo(0, size/2);\n        ctx.lineTo(-size/2, 0);\n        ctx.closePath();\n        ctx.fill();\n        \n        // Shine\n        ctx.fillStyle = 'rgba(255,255,255,0.3)';\n        ctx.beginPath();\n        ctx.moveTo(0, -size/2);\n        ctx.lineTo(size/2, 0);\n        ctx.lineTo(0, 0);\n        ctx.closePath();\n        ctx.fill();\n\n        ctx.restore();\n    }\n\n    function gameLoop(now) {\n        if (gameState !== 'PLAYING') return;\n        const deltaTime = (now - lastTime) / 1000;\n        lastTime = now;\n        timeLeft -= deltaTime;\n\n        if (timeLeft <= 0) {\n            gameState = 'GAMEOVER';\n            gameOverScreen.style.display = 'block';\n            finalScoreText.innerText = `Score: ${score}`;\n            return;\n        }\n\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        // UI Text\n        ctx.fillStyle = 'white';\n        ctx.font = 'bold 24px Arial';\n        ctx.textAlign = 'left';\n        ctx.fillText(`Score: ${score}`, 20, 40);\n        ctx.textAlign = 'right';\n        ctx.fillText(`Time: ${Math.ceil(timeLeft)}s`, canvas.width - 20, 40);\n\n        // Draw Grid\n        for (let r = 0; r < GRID_SIZE; r++) {\n            for (let c = 0; c < GRID_SIZE; c++) {\n                const gem = grid[r][c];\n                if (!gem) continue;\n\n                // Animate drop\n                if (gem.offsetY < 0) {\n                    gem.offsetY += 0.2;\n                    if (gem.offsetY > 0) gem.offsetY = 0;\n                }\n\n                const drawX = offsetX + c * cellSize;\n                const drawY = offsetY + (r + gem.offsetY) * cellSize;\n                const isSelected = selectedGem && selectedGem.r === r && selectedGem.c === c;\n                \n                drawGem(ctx, drawX, drawY, gem.type, 1, gem.alpha, isSelected);\n            }\n        }\n\n        requestAnimationFrame(gameLoop);\n    }\n\n    resize();\n</script>\n</body>\n</html>","shareCount":0,"thumbnailUrl":"https://picsum.photos/seed/1767887087975/400/600","hashtags":["#GameAI","#MadeWithPlai"],"likeCount":0,"title":"My Game","creator":{"username":"aymanon","id":"rfsHDzhIygWDjkEoDT7RDvwBI2u1","profilePicture":"https://api.dicebear.com/7.x/avataaars/png?seed=rfsHDzhIygWDjkEoDT7RDvwBI2u1","displayName":"aymanon"},"createdAt":"2026-01-08T16:44:47.976849","description":"bsbdhdh","gameType":"html5","playCount":0,"id":"GNvARKaa9R1djbf9qKH1"},{"likeCount":0,"createdAt":"2026-01-08T16:03:00.274741","thumbnailUrl":"https://picsum.photos/seed/1767884580273/400/600","creator":{"id":"rfsHDzhIygWDjkEoDT7RDvwBI2u1","username":"aymanon","profilePicture":"https://api.dicebear.com/7.x/avataaars/png?seed=rfsHDzhIygWDjkEoDT7RDvwBI2u1","displayName":"aymanon"},"hashtags":["#GameAI","#MadeWithPlai"],"description":"hvwtuhuhe","playCount":0,"title":"New Game","gameUrl":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n    <title>Neon Overdrive</title>\n    <style>\n        body { margin: 0; overflow: hidden; touch-action: none; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }\n        canvas { display: block; width: 100vw; height: 100vh; }\n        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center; color: #fff; text-shadow: 0 0 10px #0ff; }\n        .overlay { background: rgba(0, 0, 0, 0.8); padding: 20px; border-radius: 15px; border: 2px solid #0ff; text-align: center; pointer-events: auto; }\n        h1 { margin: 0 0 10px 0; font-size: 3em; color: #0ff; text-transform: uppercase; letter-spacing: 5px; }\n        p { margin: 10px 0; font-size: 1.2em; }\n        button { background: #0ff; border: none; padding: 15px 40px; font-size: 1.5em; font-weight: bold; cursor: pointer; border-radius: 5px; transition: 0.3s; margin-top: 20px; }\n        button:hover { background: #fff; box-shadow: 0 0 20px #0ff; }\n        #scoreBoard { position: absolute; top: 20px; left: 20px; font-size: 24px; font-weight: bold; color: #0ff; text-shadow: 0 0 5px #000; }\n    </style>\n</head>\n<body>\n    <canvas id=\"gameCanvas\"></canvas>\n    <div id=\"scoreBoard\" style=\"display:none\">SCORE: 0</div>\n    <div id=\"ui\">\n        <div id=\"startScreen\" class=\"overlay\">\n            <h1>NEON OVERDRIVE</h1>\n            <p>Dodge traffic at light speed!</p>\n            <p>Drag or Tap sides to steer</p>\n            <button onclick=\"startGame()\">START RACE</button>\n        </div>\n        <div id=\"gameOverScreen\" class=\"overlay\" style=\"display:none\">\n            <h1>CRASHED!</h1>\n            <p id=\"finalScoreText\">SCORE: 0</p>\n            <button onclick=\"startGame()\">RETRY</button>\n        </div>\n    </div>\n\n    <script>\n        const canvas = document.getElementById('gameCanvas');\n        const ctx = canvas.getContext('2d');\n        const scoreBoard = document.getElementById('scoreBoard');\n        const startScreen = document.getElementById('startScreen');\n        const gameOverScreen = document.getElementById('gameOverScreen');\n        const finalScoreText = document.getElementById('finalScoreText');\n\n        let gameActive = false;\n        let score = 0;\n        let speed = 8;\n        let playerX = 0;\n        let targetX = 0;\n        let obstacles = [];\n        let particles = [];\n        let roadOffset = 0;\n        let frame = 0;\n\n        const LANES = 3;\n        const PLAYER_SIZE = 40;\n        const OBSTACLE_WIDTH = 50;\n        const OBSTACLE_HEIGHT = 80;\n\n        function resize() {\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n            playerX = canvas.width / 2;\n            targetX = playerX;\n        }\n\n        window.addEventListener('resize', resize);\n        resize();\n\n        // Input Handling\n        const handleInput = (e) => {\n            if (!gameActive) return;\n            const clientX = e.touches ? e.touches[0].clientX : e.clientX;\n            targetX = clientX;\n        };\n\n        window.addEventListener('mousemove', handleInput);\n        window.addEventListener('touchstart', handleInput);\n        window.addEventListener('touchmove', handleInput);\n\n        function startGame() {\n            gameActive = true;\n            score = 0;\n            speed = 8;\n            obstacles = [];\n            particles = [];\n            playerX = canvas.width / 2;\n            targetX = playerX;\n            startScreen.style.display = 'none';\n            gameOverScreen.style.display = 'none';\n            scoreBoard.style.display = 'block';\n            animate();\n        }\n\n        function spawnObstacle() {\n            const laneWidth = canvas.width / LANES;\n            const lane = Math.floor(Math.random() * LANES);\n            const x = (lane * laneWidth) + (laneWidth / 2);\n            const color = `hsl(${Math.random() * 60 + 300}, 100%, 60%)`;\n            obstacles.push({ x, y: -100, color });\n        }\n\n        function createExplosion(x, y, color) {\n            for (let i = 0; i < 20; i++) {\n                particles.push({\n                    x, y,\n                    vx: (Math.random() - 0.5) * 10,\n                    vy: (Math.random() - 0.5) * 10,\n                    life: 1,\n                    color\n                });\n            }\n        }\n\n        function update() {\n            if (!gameActive) return;\n\n            frame++;\n            score += 1;\n            speed += 0.002;\n\n            // Move player smoothly\n            playerX += (targetX - playerX) * 0.15;\n\n            // Road animation\n            roadOffset = (roadOffset + speed) % 100;\n\n            // Spawn obstacles\n            if (frame % Math.max(20, Math.floor(60 - speed)) === 0) {\n                spawnObstacle();\n            }\n\n            // Update obstacles\n            for (let i = obstacles.length - 1; i >= 0; i--) {\n                let o = obstacles[i];\n                o.y += speed;\n\n                // Collision Check\n                if (Math.abs(o.x - playerX) < 45 && Math.abs(o.y - (canvas.height - 100)) < 60) {\n                    gameOver();\n                }\n\n                if (o.y > canvas.height + 100) {\n                    obstacles.splice(i, 1);\n                }\n            }\n\n            // Update particles\n            for (let i = particles.length - 1; i >= 0; i--) {\n                let p = particles[i];\n                p.x += p.vx;\n                p.y += p.vy;\n                p.life -= 0.02;\n                if (p.life <= 0) particles.splice(i, 1);\n            }\n\n            scoreBoard.innerText = `SCORE: ${Math.floor(score / 10)}`;\n        }\n\n        function draw() {\n            // Background\n            ctx.fillStyle = '#050510';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            // Draw Road Lines\n            ctx.strokeStyle = '#222244';\n            ctx.lineWidth = 4;\n            for (let i = 1; i < LANES; i++) {\n                let x = (canvas.width / LANES) * i;\n                ctx.beginPath();\n                ctx.setLineDash([40, 40]);\n                ctx.lineDashOffset = -roadOffset * 2;\n                ctx.moveTo(x, 0);\n                ctx.lineTo(x, canvas.height);\n                ctx.stroke();\n            }\n\n            // Draw Obstacles\n            obstacles.forEach(o => {\n                ctx.shadowBlur = 15;\n                ctx.shadowColor = o.color;\n                ctx.fillStyle = o.color;\n                ctx.fillRect(o.x - 25, o.y - 40, 50, 80);\n                \n                // Details\n                ctx.fillStyle = 'rgba(255,255,255,0.3)';\n                ctx.fillRect(o.x - 20, o.y - 35, 10, 20);\n                ctx.fillRect(o.x + 10, o.y - 35, 10, 20);\n            });\n\n            // Draw Player\n            ctx.shadowBlur = 20;\n            ctx.shadowColor = '#0ff';\n            ctx.fillStyle = '#0ff';\n            const pY = canvas.height - 100;\n            ctx.beginPath();\n            ctx.moveTo(playerX, pY - 40);\n            ctx.lineTo(playerX - 25, pY + 20);\n            ctx.lineTo(playerX + 25, pY + 20);\n            ctx.closePath();\n            ctx.fill();\n\n            // Engine Flame\n            ctx.fillStyle = '#f0f';\n            ctx.beginPath();\n            ctx.moveTo(playerX - 10, pY + 20);\n            ctx.lineTo(playerX + 10, pY + 20);\n            ctx.lineTo(playerX, pY + 20 + (Math.random() * 20));\n            ctx.fill();\n\n            // Draw Particles\n            particles.forEach(p => {\n                ctx.globalAlpha = p.life;\n                ctx.fillStyle = p.color;\n                ctx.fillRect(p.x, p.y, 4, 4);\n            });\n            ctx.globalAlpha = 1;\n            ctx.shadowBlur = 0;\n        }\n\n        function gameOver() {\n            gameActive = false;\n            createExplosion(playerX, canvas.height - 100, '#0ff');\n            finalScoreText.innerText = `SCORE: ${Math.floor(score / 10)}`;\n            gameOverScreen.style.display = 'block';\n            scoreBoard.style.display = 'none';\n        }\n\n        function animate() {\n            if (!gameActive && particles.length === 0) return;\n            update();\n            draw();\n            requestAnimationFrame(animate);\n        }\n\n        // Initial Draw\n        draw();\n    </script>\n</body>\n</html>","commentCount":0,"gameType":"html5","shareCount":0,"id":"aliXZp46NGUvMw9Zigmm"},{"hashtags":["#GameAI","#MadeWithPlai"],"description":"hi","createdAt":"2026-01-08T13:48:34.566173","playCount":0,"thumbnailUrl":"https://picsum.photos/seed/1767876514565/400/600","likeCount":0,"gameUrl":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n    <title>Gem Match Relax</title>\n    <style>\n        body { \n            margin: 0; \n            overflow: hidden; \n            touch-action: none; \n            background: #1a1a2e;\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n        }\n        canvas { \n            display: block; \n            width: 100vw; \n            height: 100vh; \n        }\n    </style>\n</head>\n<body>\n    <canvas id=\"gameCanvas\"></canvas>\n\n    <script>\n        const canvas = document.getElementById('gameCanvas');\n        const ctx = canvas.getContext('2d');\n\n        // Game Constants\n        const GRID_SIZE = 7;\n        const COLORS = ['#FF595E', '#FFCA3A', '#8AC926', '#1982C4', '#6A4C93', '#FF924C'];\n        const ANIM_SPEED = 0.2;\n\n        // Game State\n        let state = 'START'; // START, PLAYING, ANIMATING, GAMEOVER\n        let grid = [];\n        let cellSize = 0;\n        let offsetX = 0;\n        let offsetY = 0;\n        let score = 0;\n        let selected = null;\n        let animations = [];\n        let particles = [];\n\n        function init() {\n            resize();\n            createGrid();\n            requestAnimationFrame(gameLoop);\n        }\n\n        function resize() {\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n            cellSize = Math.min(canvas.width, canvas.height) / (GRID_SIZE + 1);\n            offsetX = (canvas.width - (cellSize * GRID_SIZE)) / 2;\n            offsetY = (canvas.height - (cellSize * GRID_SIZE)) / 2;\n        }\n\n        window.addEventListener('resize', resize);\n\n        function createGrid() {\n            grid = [];\n            for (let r = 0; r < GRID_SIZE; r++) {\n                grid[r] = [];\n                for (let c = 0; c < GRID_SIZE; c++) {\n                    let color;\n                    do {\n                        color = Math.floor(Math.random() * COLORS.length);\n                    } while (\n                        (c > 1 && grid[r][c-1].type === color && grid[r][c-2].type === color) ||\n                        (r > 1 && grid[r-1][c].type === color && grid[r-2][c].type === color)\n                    );\n                    grid[r][c] = { \n                        type: color, \n                        x: c, \n                        y: r, \n                        visX: c, \n                        visY: r, \n                        scale: 1,\n                        alpha: 1 \n                    };\n                }\n            }\n        }\n\n        function getMatches() {\n            let matches = new Set();\n            // Horizontal\n            for (let r = 0; r < GRID_SIZE; r++) {\n                for (let c = 0; c < GRID_SIZE - 2; c++) {\n                    if (grid[r][c].type === grid[r][c+1].type && grid[r][c].type === grid[r][c+2].type) {\n                        matches.add(`${r},${c}`); matches.add(`${r},${c+1}`); matches.add(`${r},${c+2}`);\n                    }\n                }\n            }\n            // Vertical\n            for (let c = 0; c < GRID_SIZE; c++) {\n                for (let r = 0; r < GRID_SIZE - 2; r++) {\n                    if (grid[r][c].type === grid[r+1][c].type && grid[r][c].type === grid[r+2][c].type) {\n                        matches.add(`${r},${c}`); matches.add(`${r+1},${c}`); matches.add(`${r+2},${c}`);\n                    }\n                }\n            }\n            return Array.from(matches).map(s => {\n                let [r, c] = s.split(',').map(Number);\n                return {r, c};\n            });\n        }\n\n        function handleMatches() {\n            const matches = getMatches();\n            if (matches.length > 0) {\n                state = 'ANIMATING';\n                score += matches.length * 10;\n                \n                matches.forEach(m => {\n                    createParticles(m.c * cellSize + offsetX + cellSize/2, m.r * cellSize + offsetY + cellSize/2, COLORS[grid[m.r][m.c].type]);\n                    grid[m.r][m.c].type = -1;\n                });\n\n                setTimeout(() => {\n                    dropGems();\n                }, 300);\n            } else {\n                state = 'PLAYING';\n            }\n        }\n\n        function dropGems() {\n            for (let c = 0; c < GRID_SIZE; c++) {\n                let emptySpaces = 0;\n                for (let r = GRID_SIZE - 1; r >= 0; r--) {\n                    if (grid[r][c].type === -1) {\n                        emptySpaces++;\n                    } else if (emptySpaces > 0) {\n                        grid[r + emptySpaces][c].type = grid[r][c].type;\n                        grid[r + emptySpaces][c].visY = r;\n                        grid[r][c].type = -1;\n                    }\n                }\n                for (let r = 0; r < emptySpaces; r++) {\n                    grid[r][c].type = Math.floor(Math.random() * COLORS.length);\n                    grid[r][c].visY = r - emptySpaces;\n                }\n            }\n            setTimeout(handleMatches, 400);\n        }\n\n        function createParticles(x, y, color) {\n            for (let i = 0; i < 8; i++) {\n                particles.push({\n                    x, y, \n                    vx: (Math.random() - 0.5) * 10,\n                    vy: (Math.random() - 0.5) * 10,\n                    life: 1.0,\n                    color\n                });\n            }\n        }\n\n        function drawGem(ctx, x, y, size, colorIdx, scale = 1) {\n            const pad = size * 0.1;\n            const s = size * scale - pad * 2;\n            const cx = x + size / 2;\n            const cy = y + size / 2;\n\n            ctx.fillStyle = COLORS[colorIdx];\n            ctx.beginPath();\n            ctx.moveTo(cx, cy - s/2);\n            ctx.lineTo(cx + s/2, cy);\n            ctx.lineTo(cx, cy + s/2);\n            ctx.lineTo(cx - s/2, cy);\n            ctx.closePath();\n            ctx.fill();\n            \n            ctx.strokeStyle = 'rgba(255,255,255,0.3)';\n            ctx.lineWidth = 2;\n            ctx.stroke();\n        }\n\n        function gameLoop() {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            \n            // Background Gradient\n            let grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width);\n            grad.addColorStop(0, '#1a1a2e');\n            grad.addColorStop(1, '#0f0f1b');\n            ctx.fillStyle = grad;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            if (state === 'START') {\n                ctx.fillStyle = 'white';\n                ctx.textAlign = 'center';\n                ctx.font = 'bold 40px Arial';\n                ctx.fillText('GEM MATCH', canvas.width / 2, canvas.height / 2 - 40);\n                ctx.font = '20px Arial';\n                ctx.fillText('Tap to Start Relaxing', canvas.width / 2, canvas.height / 2 + 20);\n            } else {\n                // Draw Grid\n                for (let r = 0; r < GRID_SIZE; r++) {\n                    for (let c = 0; c < GRID_SIZE; c++) {\n                        const gem = grid[r][c];\n                        // Smoothly move visual position to actual position\n                        gem.visX += (gem.x - gem.visX) * ANIM_SPEED;\n                        gem.visY += (gem.y - gem.visY) * ANIM_SPEED;\n\n                        if (gem.type !== -1) {\n                            const isSelected = selected && selected.r === r && selected.c === c;\n                            const drawScale = isSelected ? 1.1 + Math.sin(Date.now() / 100) * 0.05 : 1;\n                            drawGem(ctx, gem.visX * cellSize + offsetX, gem.visY * cellSize + offsetY, cellSize, gem.type, drawScale);\n                        }\n                    }\n                }\n\n                // Particles\n                particles.forEach((p, i) => {\n                    p.x += p.vx;\n                    p.y += p.vy;\n                    p.life -= 0.02;\n                    ctx.globalAlpha = p.life;\n                    ctx.fillStyle = p.color;\n                    ctx.fillRect(p.x, p.y, 4, 4);\n                    if (p.life <= 0) particles.splice(i, 1);\n                });\n                ctx.globalAlpha = 1;\n\n                // Score\n                ctx.fillStyle = 'white';\n                ctx.textAlign = 'center';\n                ctx.font = 'bold 24px Arial';\n                ctx.fillText(`Score: ${score}`, canvas.width / 2, offsetY / 2);\n            }\n\n            requestAnimationFrame(gameLoop);\n        }\n\n        function handleInput(e) {\n            const touch = e.touches ? e.touches[0] : e;\n            const x = touch.clientX;\n            const y = touch.clientY;\n\n            if (state === 'START') {\n                state = 'PLAYING';\n                score = 0;\n                return;\n            }\n\n            if (state !== 'PLAYING') return;\n\n            const c = Math.floor((x - offsetX) / cellSize);\n            const r = Math.floor((y - offsetY) / cellSize);\n\n            if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE) {\n                if (!selected) {\n                    selected = {r, c};\n                } else {\n                    const dist = Math.abs(selected.r - r) + Math.abs(selected.c - c);\n                    if (dist === 1) {\n                        // Swap\n                        const temp = grid[r][c].type;\n                        grid[r][c].type = grid[selected.r][selected.c].type;\n                        grid[selected.r][selected.c].type = temp;\n                        \n                        if (getMatches().length === 0) {\n                            // Swap back if no match\n                            setTimeout(() => {\n                                const back = grid[r][c].type;\n                                grid[r][c].type = grid[selected.r][selected.c].type;\n                                grid[selected.r][selected.c].type = back;\n                            }, 200);\n                        } else {\n                            handleMatches();\n                        }\n                        selected = null;\n                    } else {\n                        selected = {r, c};\n                    }\n                }\n            } else {\n                selected = null;\n            }\n        }\n\n        canvas.addEventListener('mousedown', handleInput);\n        canvas.addEventListener('touchstart', (e) => {\n            e.preventDefault();\n            handleInput(e);\n        }, {passive: false});\n\n        init();\n    </script>\n</body>\n</html>","creator":{"id":"0P0IFPXfiZMOJISAhBnZ1MgPtAv2","displayName":"Guest Player","username":"guest_0P0IFP","profilePicture":"https://api.dicebear.com/7.x/avataaars/png?seed=0P0IFPXfiZMOJISAhBnZ1MgPtAv2"},"commentCount":0,"shareCount":0,"title":"New Game","gameType":"html5","id":"l9NfnEs7B0tT7r6GfogP"}]}